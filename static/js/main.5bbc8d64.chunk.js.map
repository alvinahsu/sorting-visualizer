{"version":3,"sources":["SortingAlgorithms/sortingAlgorithms.js","SortingVisualizer/SortingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["swap","array","left","right","animations","push","temp","getMergeSortAnimations","length","helperArray","slice","mergeSortHelper","startIdx","endIdx","middleIdx","Math","floor","i","k","j","doMerge","getQuickSortAnimations","quickSortHelper","pivot","low","high","p","min","max","random","getPivot","border","partition","getHeapSortAnimations","n","heapify","heapSortHelper","arr","largest","l","r","getBubbleSortAnimations","len","isSwapped","bubbleSortHelper","getInsertionSortAnimations","insertionSortHelper","getSelectionSortAnimations","min_index","selectionSortHelper","PRIMARY_COLOR","SECONDARY_COLOR","array_size","SortingVisualizer","props","state","document","title","this","resetArray","window","innerWidth","getElementById","setState","buttons","getElementsByTagName","disabled","newSize","callback","sortingAlgorithms","timer","ms","Promise","res","setTimeout","enableB","a","arrayBars","getElementsByClassName","barOneIdx","barTwoIdx","barOneStyle","style","barTwoStyle","color","backgroundColor","newHeight","height","load","isSwap","count","colorCount","first","second","className","onClick","type","defaultValue","step","onChange","handleChange","e","changeArraySize","target","value","id","mergeSort","enableButton","disableButton","quickSort","heapSort","bubbleSort","insertionSort","selectionSort","map","idx","React","Component","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.5bbc8d64.chunk.js","sourcesContent":["/*\r\n* Author: Alvin Hsu\r\n* Date: 9/4/2021\r\n*\r\n*\r\n* File Name: sortingAlgorithms.js\r\n* Description: This file contains the sorting algorithmns that will\r\n* be used by the sorting visualizer file. An animations array is used\r\n* by each sorting algorithm that either pushes [index, index] used when\r\n* comparing two indexes or [index, height], when needing to change the height\r\n* at an index. This allows for the visualization of comparison and height change.\r\n*/\r\n\r\n/******************* GENERAL HELPER FUNCTIONS *********************/\r\n/**\r\n * This function gives a random int from the interval min and max inclusive\r\n * \r\n * @param {*} min lowest num\r\n * @param {*} max highest num\r\n * @returns number in between min and max inclusive\r\n */\r\nfunction randomIntFromInterval(min, max) {\r\n  // min and max included\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\n/**\r\n * This function will swap two elements given the left and\r\n * right indeces. It will also push either [index,index] \r\n * when comparison two indeces or [index, height] when \r\n * changing height at and index to the animations \r\n * array which will be used for visualization.\r\n * \r\n * @param {*} array input array\r\n * @param {*} left left index\r\n * @param {*} right right index\r\n * @param {*} animations animations array\r\n */\r\nfunction swap(array, left, right , animations){\r\n  //indicate swap - used to determine when a swap is ocurring\r\n  let next = -1;\r\n  animations.push([next, next]);\r\n\r\n  let temp = array[left];\r\n  \r\n  //push change animation\r\n  animations.push([left, array[right]]);\r\n  animations.push([right, temp]);\r\n\r\n  //push compare animation\r\n  animations.push([left, right]);\r\n  animations.push([left, right]);\r\n  \r\n  //swap the two elements\r\n  array[left] = array[right];\r\n  array[right] = temp;\r\n}\r\n/******************************************************************/\r\n\r\n\r\n\r\n\r\n\r\n/************************** MERGE SORT ****************************/\r\n/**\r\n * This function is the driver function for the merge sort algorithm.\r\n * It calls the mergeSortHelper function that contains the code to update\r\n * the animations array for the visualizations. \r\n * \r\n * @param {*} array input array\r\n * @returns animations array\r\n */\r\nexport function getMergeSortAnimations(array) {\r\n  const animations = [];\r\n  if (array.length <= 1) return array;\r\n  //get a copy of the array keep track of values during merges\r\n  const helperArray = array.slice();\r\n  mergeSortHelper(array, 0, array.length - 1, helperArray, animations);\r\n  return animations;\r\n}\r\n  \r\n/**\r\n * This function will recursively break down an array into two sub arrays\r\n * from the starting index to the mid, and the mid+1 index to the end index.\r\n * It then calls doMerge which will sort and merge the subarrays.\r\n * \r\n * @param {*} array input array\r\n * @param {*} startIdx starting index\r\n * @param {*} endIdx ending index\r\n * @param {*} helperArray helper array to keep track of values\r\n * @param {*} animations animations array\r\n */\r\nfunction mergeSortHelper(array, startIdx, endIdx, helperArray, animations) {\r\n  if (startIdx === endIdx) return;\r\n\r\n  //get mid index\r\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n  \r\n  //Merge from start to mid, and mid+1 to end\r\n  //Use helper array to keep track of recursively broken down subarrays\r\n  mergeSortHelper(helperArray, startIdx, middleIdx, array, animations);\r\n  mergeSortHelper(helperArray, middleIdx + 1, endIdx, array, animations);\r\n  doMerge(array, startIdx, middleIdx, endIdx, helperArray, animations);\r\n}\r\n  \r\n\r\n/**\r\n * This function merges two sub arrays into one. It uses the helper array\r\n * which contains the values of the two array, one starting from the startIdx\r\n * and the other from the middleIdx+1. It will push comparing values to the \r\n * animations array which will be used to visualizations. The main input array\r\n * will be changed to contain the values of the helper arrays.\r\n * \r\n * @param {*} array input array\r\n * @param {*} startIdx starting index\r\n * @param {*} middleIdx middle index\r\n * @param {*} endIdx ending index\r\n * @param {*} helperArray helper array to keep track of values\r\n * @param {*} animations animations array\r\n */\r\nfunction doMerge(array,startIdx,middleIdx,endIdx,helperArray,animations){\r\n  let i = startIdx, k = startIdx;\r\n  let j = middleIdx + 1;\r\n  //Iterate through valid indeces of the two subarrays\r\n  while (i <= middleIdx && j <= endIdx) {\r\n\r\n    // Comparing: push [index and index] to change color once, and push again to revert\r\n    animations.push([i, j]);\r\n    animations.push([i, j]);\r\n\r\n    //If the left subarray is less than the right subarray, push left value\r\n    if (helperArray[i] <= helperArray[j]) {\r\n      // Change: push [index and height] to set new height and index\r\n      animations.push([k, helperArray[i]]);\r\n      //place value in main array and increment pointers\r\n      array[k++] = helperArray[i++];\r\n\r\n    //otherwise, push right value\r\n    } else {\r\n      //Change: push [index and height] to set new height and index\r\n      animations.push([k, helperArray[j]]);\r\n      //place value in main array and increment pointers\r\n      array[k++] = helperArray[j++];\r\n    }\r\n  }\r\n\r\n  //If we still have values in one of the subarrays, we push all values onto main array\r\n  while (i <= middleIdx) {\r\n    //Comparison\r\n    animations.push([i, i]);\r\n    animations.push([i, i]);\r\n\r\n    //Change\r\n    animations.push([k, helperArray[i]]);\r\n    array[k++] = helperArray[i++];\r\n  }\r\n  //If we still have values in one of the subarrays, we push all values onto main array\r\n  while (j <= endIdx) {\r\n    //Comparison\r\n    animations.push([j, j]);\r\n    animations.push([j, j]);\r\n\r\n    //Change\r\n    animations.push([k, helperArray[j]]);\r\n    array[k++] = helperArray[j++];\r\n  }\r\n}\r\n/******************************************************************/\r\n\r\n\r\n\r\n\r\n\r\n/************************** QUICK SORT ****************************/\r\n/**\r\n * This function is the driver function for the quick sort algorithm.\r\n * It calls the quickSortHelper function that contains the code to update\r\n * the animations array for the visualizations. \r\n * \r\n * @param {*} array input array \r\n * @returns animations array\r\n */\r\nexport function getQuickSortAnimations(array) {\r\n  const animations = [];\r\n  if (array.length <= 1) return array;\r\n  quickSortHelper(array, 0, array.length - 1, animations);\r\n  return animations;\r\n}\r\n\r\n/**\r\n * This function will recursively break the input array into\r\n * two subarrays depending on the pivot which is given by a\r\n * random index from the range left to right inclusive. \r\n * \r\n * @param {*} array input array \r\n * @param {*} left left index\r\n * @param {*} right right index\r\n * @param {*} animations animations array\r\n */\r\nfunction quickSortHelper(array, left, right, animations){\r\n  //Make sure that there are more than one element between\r\n  //left and right, otherwise single element is sorted\r\n  if (right - left >= 1){\r\n    //Get the pivot point and sort partitions\r\n    let pivot = partition(array, left, right ,animations);\r\n    quickSortHelper(array, left, pivot-1,animations);\r\n    quickSortHelper(array, pivot+1, right ,animations);\r\n  }\r\n}\r\n\r\n/**\r\n * This function will get the pivot for the algorithm which\r\n * is a random int from the interval left to right\r\n * \r\n * @param {*} left left index\r\n * @param {*} right right index\r\n * @returns random number between left and right inclusive\r\n */\r\nfunction getPivot (left, right){\r\n  return randomIntFromInterval(left, right);\r\n}\r\n\r\n/**\r\n * This function sorts the partition by placing the \r\n * pivot value all the way to the left and places smallers \r\n * numbers to the right of it. It then places the pivot\r\n * value to the right of the last smaller number which \r\n * ensures that all numbers to the left of the pivot is\r\n * smaller and sorted.\r\n * \r\n * @param {*} array input array\r\n * @param {*} low left index\r\n * @param {*} high right index\r\n * @param {*} animations animations index\r\n * @returns position where pivot is supposed to be\r\n */\r\nfunction partition(array, low, high,animations){\r\n  //Get pivot index\r\n  let p = getPivot(low, high);\r\n\r\n  //put pivot at the lowest index\r\n  swap(array, low, p,animations);\r\n  //Border is at the right of lowest(currently pivot) index\r\n  let border = low + 1;\r\n  //Interate from border to high\r\n  for (let i = border; i <= high; i++){\r\n    //Compare\r\n    animations.push([i, low]);\r\n    animations.push([i, low]);\r\n    //If the value at i is lower than pivot\r\n    if (array[i] < array[low]){\r\n      //swap and increment border\r\n      swap(array, i, border++, animations);\r\n    }\r\n  }\r\n  //put pivot next to the last smaller element\r\n  swap(array, low, border-1,animations);\r\n  return border-1;\r\n}\r\n\r\n/******************************************************************/\r\n\r\n\r\n\r\n\r\n\r\n/************************** HEAP SORT ****************************/\r\n/**\r\n * This function is the driver function for the heap sort algorithm.\r\n * It calls the heapSortHelper function that contains the code to update\r\n * the animations array for the visualizations. \r\n * @param {*} array input array \r\n * @returns animations array\r\n */\r\nexport function getHeapSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    heapSortHelper(array, animations);\r\n    return animations;\r\n}\r\n\r\n/**\r\n * This function will create heaps from the input array\r\n * and move the largest elements to the end. It then builds\r\n * another heap from the change array to another heap and repeat\r\n * this process until the array is sorted.\r\n * \r\n * @param {*} array input array\r\n * @param {*} animations animations array\r\n */\r\nfunction heapSortHelper(array, animations){\r\n  let n = array.length;\r\n\r\n  //Build max heap (placing the largest number at the root)\r\n  for (let i = Math.floor(n/2)-1; i>=0; i--){\r\n    heapify(array, n ,i, animations);\r\n  }\r\n\r\n  //Swap max to the end index, and then build heap again\r\n  for (let i = n - 1; i > 0; i--){\r\n    swap(array, 0, i, animations);\r\n    heapify (array, i, 0, animations);\r\n  }\r\n}\r\n/**\r\n * This function will turn the input array into a heap with node i \r\n * which is an index in the array. \r\n * \r\n * @param {*} arr input array\r\n * @param {*} n size of heap\r\n * @param {*} i index in array\r\n * @param {*} animations animations array\r\n */\r\nfunction heapify(arr, n, i, animations) {\r\n  let largest = i; // Initialize largest as root\r\n  let l = 2 * i + 1; // left = 2*i + 1\r\n  let r = 2 * i + 2; // right = 2*i + 2\r\n\r\n  if (l < n){\r\n    animations.push([l, largest]);\r\n    animations.push([l, largest]);\r\n  }\r\n  // If left child is larger than root\r\n  if (l < n && arr[l] > arr[largest])\r\n      largest = l;\r\n\r\n  if (r < n){\r\n    animations.push([r, largest]);\r\n    animations.push([r, largest]);\r\n  }\r\n  // If right child is larger than largest so far\r\n  if (r < n && arr[r] > arr[largest])\r\n      largest = r;\r\n\r\n  // If largest is not root\r\n  if (largest !== i) {\r\n      swap(arr, i, largest, animations);\r\n\r\n      // Recursively heapify the affected sub-tree\r\n      heapify(arr, n, largest, animations);\r\n  }\r\n}\r\n/******************************************************************/\r\n\r\n\r\n\r\n\r\n\r\n/************************** BUBBLE SORT ****************************/\r\n/**\r\n * This function is the driver function for the bubble sort algorithm.\r\n * It calls the bubbleSortHelper function that contains the code to update\r\n * the animations array for the visualizations. \r\n * @param {*} array input array \r\n * @returns animations array\r\n */\r\nexport function getBubbleSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    bubbleSortHelper(array, animations);\r\n    return animations;\r\n}\r\n\r\n/**\r\n * This function loop and swap adjacent elements if the left\r\n * element is greater than the right element. This will continue\r\n * to loop until there is a full loop with no element swap. This ends\r\n * with a sorted array.\r\n * \r\n * @param {*} array input array\r\n * @param {*} animations animations array\r\n */\r\nfunction bubbleSortHelper(array, animations){\r\n  let i, j;\r\n  let len = array.length;\r\n  //Check if we swapped an element or not\r\n  let isSwapped = false;\r\n  //worse case scenerio, O(n) outer loop\r\n  for(i =0; i < len; i++){\r\n    isSwapped = false;\r\n    //loop through entire array\r\n    for(j = 0; j < len; j++){\r\n        if (j+1 < len){\r\n          animations.push([j, j+1]);\r\n          animations.push([j, j+1]);\r\n        }\r\n        //if the left is greater than right, swap\r\n        if(array[j] > array[j + 1]){\r\n          swap(array, j, j+1, animations);\r\n          isSwapped = true;\r\n        }\r\n    }\r\n    // If no two elements were swapped by inner loop, then break \r\n    if(!isSwapped){\r\n      break;\r\n    }\r\n  } \r\n} \r\n/******************************************************************/\r\n\r\n\r\n\r\n\r\n\r\n/************************** INSERTION SORT ****************************/\r\n/**\r\n * This function is the driver function for the insertion sort algorithm.\r\n * It calls the insertionSortHelper function that contains the code to update\r\n * the animations array for the visualizations. \r\n * @param {*} array input array \r\n * @returns animations array\r\n */\r\nexport function getInsertionSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    insertionSortHelper(array, array.length, animations);\r\n    return animations;\r\n}\r\n\r\n/**\r\n * This function will loop through the array and move the\r\n * right index values that are greater than the right-1 index\r\n * values to the right which will ultimately result in a sorted\r\n * array.\r\n * \r\n * @param {*} arr input array\r\n * @param {*} n array length\r\n * @param {*} animations animations array\r\n */\r\nfunction insertionSortHelper(arr, n, animations){\r\n  let i, j;\r\n  //Loop from index 1 to n-1 and compare previous values \r\n  for (i = 1; i < n; i++) { \r\n    j = i ; \r\n\r\n    animations.push([j, i]);\r\n    animations.push([j, i]);\r\n    //Move greater elements to the right of lower elements\r\n    while (j > 0 && arr[j-1] > arr[j]) { \r\n      animations.push([j, i]);\r\n      animations.push([j, i]);\r\n      swap(arr, j, j-1, animations);\r\n      j--; \r\n    } \r\n  } \r\n}\r\n/******************************************************************/\r\n\r\n\r\n\r\n\r\n\r\n/************************** SELECTION SORT ****************************/\r\n/**\r\n * This function is the driver function for the selection sort algorithm.\r\n * It calls the selectionSortHelper function that contains the code to update\r\n * the animations array for the visualizations. \r\n * @param {*} array input array \r\n * @returns animations array\r\n */\r\nexport function getSelectionSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    selectionSortHelper(array, array.length, animations);\r\n    return animations;\r\n}\r\n\r\n/**\r\n * This function will loop through the array and\r\n * place the minimum value of the subarray[i...n-1]\r\n * in the unsorted partitions. This will ultimately \r\n * lead to a sorted array.\r\n * \r\n * @param {*} arr input array \r\n * @param {*} n length of array\r\n * @param {*} animations animations array\r\n */\r\nfunction selectionSortHelper(arr, n, animations){\r\n  //Loop through each index\r\n  for (let i = 0; i < n; i++){\r\n    let min_index = i;\r\n    //find the minimum index\r\n    for (let j = i; j < n; j++){\r\n      animations.push([j, min_index]);\r\n      animations.push([j, min_index]);\r\n      if (arr[j] < arr[min_index]){\r\n        min_index = j;\r\n      }\r\n    }\r\n    //swap minimun value to the ith index\r\n    if (min_index !== i){\r\n      swap(arr, i, min_index, animations);\r\n    }\r\n  }\r\n}\r\n/******************************************************************/","/*\r\n* Author: Alvin Hsu\r\n* Date: 9/4/2021\r\n*\r\n* File Name: SortingVisualizer.jsx\r\n* Description: This file is the drive file for the sorting visualizer.\r\n* It contains the class SortingVisualizer and its methods that is used\r\n* to create the sorting visualizations for each sorting algorithm. It \r\n* contains HTML code for the webpage.\r\n*/\r\n\r\n/* Imports */\r\nimport React from 'react';\r\nimport './SortingVisualizer.css';\r\nimport * as sortingAlgorithms from '../SortingAlgorithms/sortingAlgorithms';\r\n\r\n/* Global variables */\r\nconst PRIMARY_COLOR = 'navy';\r\nconst SECONDARY_COLOR = 'red';\r\nlet array_size = 75;\r\nlet animation_speed_ms = 5;\r\n\r\n/**\r\n * This class contains the methods used to create a sorting\r\n * visualizations. It also contains HTML code for the webpage\r\n * as it extends React.Component.\r\n */\r\nexport default class SortingVisualizer extends React.Component{\r\n\r\n    //call constructor of super class(React.Component)\r\n    constructor(props){\r\n        super(props);\r\n\r\n        //array of ints for sorting\r\n        this.state = {\r\n            array: [],\r\n        };\r\n    }\r\n\r\n    /* When page loads, we generate array */\r\n    componentDidMount(){\r\n        //Set title for the page\r\n        document.title = \"Sorting Visualizer\";\r\n        this.resetArray();\r\n        //Resize slider max value based on width of screen\r\n        if (window.innerWidth <= 450){\r\n            document.getElementById('barRange').max = 70;\r\n        }\r\n        else {\r\n            document.getElementById('barRange').max = 150;\r\n        }\r\n    }\r\n\r\n    /* Resets the values of array */\r\n    resetArray(){\r\n        const array = [];\r\n        for (let i = 0; i < array_size; i++){\r\n            //get random ints\r\n            array.push(randomIntFromInterval(5, 500));\r\n        }\r\n        this.setState({array}); \r\n    }\r\n\r\n    /* Disables all buttons on page*/\r\n    disableButton(){\r\n        //get all buttons\r\n        let buttons = document.getElementsByTagName('button');\r\n        for (let i = 0 ;i < buttons.length; i++){\r\n            //set disabled to be true\r\n            buttons[i].disabled = true;\r\n        }\r\n        //disable slider\r\n        document.getElementById(\"barRange\").disabled = true;\r\n    }\r\n\r\n    /* Enables all buttons on page*/\r\n    enableButton(){\r\n        //get all buttons\r\n        let buttons = document.getElementsByTagName('button');\r\n        for (let i = 0 ;i < buttons.length; i++){\r\n            //set disabled to be false\r\n            buttons[i].disabled = false;\r\n        }\r\n        //enable slider\r\n        document.getElementById(\"barRange\").disabled = false;\r\n    }\r\n\r\n    /**\r\n     * This function sets the array_size to the value\r\n     * of the new input size.\r\n     * \r\n     * @param {*} newSize new size of array\r\n     */\r\n    changeArraySize(newSize){\r\n        array_size = newSize;\r\n        this.resetArray();\r\n    }\r\n\r\n\r\n    /**\r\n     * This function calls getMergeSortAnimations from sortingAlgorithms.js and uses the return\r\n     * array to create visualizations for merge sort.\r\n     *  \r\n     * @param {*} callback enable buttons function call \r\n     */\r\n    mergeSort(callback){\r\n        //get animations array\r\n        const animations = sortingAlgorithms.getMergeSortAnimations(this.state.array);\r\n\r\n        //create promise\r\n        const timer = ms => new Promise(res => setTimeout(res, ms))\r\n\r\n        /* load function */\r\n        async function load(enableB){\r\n            //loop through animations array\r\n            for (let i = 0; i < animations.length; i++) {\r\n                //get arraybars\r\n                const arrayBars = document.getElementsByClassName('array-bar');\r\n                //every two is comparison and third is change bar height\r\n                const isColorChange = i % 3 !== 2;\r\n                //change the color\r\n                if (isColorChange) {\r\n                    const [barOneIdx, barTwoIdx] = animations[i];\r\n                    const barOneStyle = arrayBars[barOneIdx].style;\r\n                    const barTwoStyle = arrayBars[barTwoIdx].style;\r\n                    //if third color, set to primary color, else sec color\r\n                    const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n                    setTimeout(() => {\r\n                        barOneStyle.backgroundColor = color;\r\n                        barTwoStyle.backgroundColor = color;\r\n                    },  animation_speed_ms);\r\n                } \r\n                //else change the height\r\n                else {\r\n                    setTimeout(() => {\r\n                        //set the height of the bar the barOneIdx\r\n                        const [barOneIdx, newHeight] = animations[i];\r\n                        const barOneStyle = arrayBars[barOneIdx].style;\r\n                        barOneStyle.height = `${newHeight}px`;\r\n                    }, animation_speed_ms);\r\n                }\r\n                await timer(animation_speed_ms);\r\n            }\r\n            //enable all buttons\r\n            enableB();\r\n        }\r\n        //call load function\r\n        load(callback);\r\n    }\r\n\r\n\r\n    /**\r\n     * This function calls getQuickSortAnimations from sortingAlgorithms.js and uses the return\r\n     * array to create visualizations for quick sort.\r\n     *  \r\n     * @param {*} callback enable buttons function call \r\n     */\r\n    quickSort(callback) {\r\n        //get animations array\r\n        const animations = sortingAlgorithms.getQuickSortAnimations(this.state.array);\r\n\r\n        //create promise\r\n        const timer = ms => new Promise(res => setTimeout(res, ms))\r\n\r\n        /* load function */\r\n        async function load(enableB){\r\n        //indicate if the next elements in array is a swap or not\r\n        let isSwap = false;\r\n        //count of swaps, count of color changes\r\n        let count = 0, colorCount = 0;\r\n        //loop through animations array;\r\n        for (let i = 0; i < animations.length; i++) {\r\n            const arrayBars = document.getElementsByClassName('array-bar');\r\n            const [first, second] = animations[i];\r\n            //if animations[i][0] == -1 && animations[i][1] == -1\r\n            //this indicates that the next two elements is swapped\r\n            if (first === -1 && second === -1){\r\n                isSwap = true;\r\n            }\r\n            //color change\r\n            else if (!isSwap && first !== -1 && second !== -1) {\r\n                colorCount++;\r\n                const [barOneIdx, barTwoIdx] = animations[i];\r\n                const barOneStyle = arrayBars[barOneIdx].style;\r\n                const barTwoStyle = arrayBars[barTwoIdx].style;\r\n                //if first colorCount, change to sec color, else primary\r\n                const color = colorCount === 1 ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n                if (colorCount === 2) colorCount = 0; //finish change, reset colorCount\r\n                setTimeout(() => {\r\n                    barOneStyle.backgroundColor = color;\r\n                    barTwoStyle.backgroundColor = color;\r\n                },  animation_speed_ms);\r\n            } \r\n            //swap \r\n            else if (isSwap && first !== -1 && second !== -1) {\r\n                count++;\r\n                const [barOneIdx, newHeight] = animations[i];\r\n                setTimeout(() => {\r\n                    const barOneStyle = arrayBars[barOneIdx].style;\r\n                    barOneStyle.height = `${newHeight}px`;\r\n                }, animation_speed_ms);\r\n                //once we swapped both elements, we reset isSwap and count\r\n                if (count === 2){\r\n                    isSwap = false;\r\n                    count = 0;\r\n                }\r\n            }\r\n\r\n            await timer(animation_speed_ms);\r\n            }\r\n            //enable all buttons\r\n            enableB();\r\n        }\r\n        //call load function\r\n        load(callback);\r\n    } \r\n\r\n    /**\r\n     * This functions call getHeapSortAnimations from sortingAlgorithms.js and uses the return\r\n     * array to create visualizations for heap sort.\r\n     *  \r\n     * @param {*} callback enable buttons function call \r\n     */\r\n    heapSort(callback) {\r\n        //get animations array\r\n        const animations = sortingAlgorithms.getHeapSortAnimations(this.state.array);\r\n\r\n        //create promise\r\n        const timer = ms => new Promise(res => setTimeout(res, ms))\r\n\r\n        /* load function */\r\n        async function load(enableB){\r\n            //indicate if the next elements in array is a swap or not\r\n            let isSwap = false; \r\n            //count of swaps, count of color changes\r\n            let count = 0, colorCount = 0;\r\n            //loop through animations array;\r\n            for (let i = 0; i < animations.length; i++) {\r\n                const arrayBars = document.getElementsByClassName('array-bar');\r\n                //if animations[i][0] == -1 && animations[i][1] == -1\r\n                //this indicates that the next two elements is swapped\r\n                const [first, second] = animations[i];\r\n                if (first === -1 && second === -1){\r\n                    isSwap = true;\r\n                }\r\n                //color change\r\n                else if (!isSwap && first !== -1 && second !== -1) {\r\n                    colorCount++;\r\n                    const [barOneIdx, barTwoIdx] = animations[i];\r\n                    const barOneStyle = arrayBars[barOneIdx].style;\r\n                    const barTwoStyle = arrayBars[barTwoIdx].style;\r\n                    //if first colorCount, change to sec color, else primary\r\n                    const color = colorCount === 1 ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n                    if (colorCount === 2) colorCount = 0;\r\n                    setTimeout(() => {\r\n                        barOneStyle.backgroundColor = color;\r\n                        barTwoStyle.backgroundColor = color;\r\n                    },  animation_speed_ms);\r\n                } \r\n                //swap\r\n                else if (isSwap && first !== -1 && second !== -1) {\r\n                    count++;\r\n                    const [barOneIdx, newHeight] = animations[i];\r\n                    setTimeout(() => {\r\n                        const barOneStyle = arrayBars[barOneIdx].style;\r\n                        barOneStyle.height = `${newHeight}px`;\r\n                    }, animation_speed_ms);\r\n                    //once we swapped both elements, we reset isSwap and count\r\n                    if (count === 2){\r\n                        isSwap = false;\r\n                        count = 0;\r\n                    }\r\n                }\r\n\r\n            await timer(animation_speed_ms);\r\n            }\r\n            //enable all buttons\r\n            enableB();\r\n        }\r\n        //call load function\r\n        load(callback);\r\n\r\n    }\r\n\r\n    /**\r\n     * This functions call getBubbleSortAnimations from sortingAlgorithms.js and uses the return\r\n     * array to create visualizations for bubble sort.\r\n     *  \r\n     * @param {*} callback enable buttons function call \r\n     */\r\n    bubbleSort(callback) {\r\n        //get animations array\r\n        const animations = sortingAlgorithms.getBubbleSortAnimations(this.state.array);\r\n        \r\n        //create promise\r\n        const timer = ms => new Promise(res => setTimeout(res, ms))\r\n\r\n        /* load function */\r\n        async function load(enableB){\r\n            //indicate if the next elements in array is a swap or not\r\n            let isSwap = false;\r\n            //count of swaps, count of color changes\r\n            let count = 0, colorCount = 0;\r\n            //loop through animations array;\r\n            for (let i = 0; i < animations.length; i++) {\r\n                const arrayBars = document.getElementsByClassName('array-bar');\r\n                //if animations[i][0] == -1 && animations[i][1] == -1\r\n                //this indicates that the next two elements is swapped\r\n                const [first, second] = animations[i];\r\n                if (first === -1 && second === -1){\r\n                    isSwap = true;\r\n                }\r\n                //color change\r\n                else if (!isSwap && first !== -1 && second !== -1) {\r\n                    colorCount++;\r\n                    const [barOneIdx, barTwoIdx] = animations[i];\r\n                    const barOneStyle = arrayBars[barOneIdx].style;\r\n                    const barTwoStyle = arrayBars[barTwoIdx].style;\r\n                    //if first colorCount, change to sec color, else primary\r\n                    const color = colorCount === 1 ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n                    if (colorCount === 2) colorCount = 0;\r\n                    setTimeout(() => {\r\n                        barOneStyle.backgroundColor = color;\r\n                        barTwoStyle.backgroundColor = color;\r\n                    },  animation_speed_ms);\r\n                } \r\n                //swap\r\n                else if (isSwap && first !== -1 && second !== -1) {\r\n                    count++;\r\n                    const [barOneIdx, newHeight] = animations[i];\r\n                    setTimeout(() => {\r\n                        const barOneStyle = arrayBars[barOneIdx].style;\r\n                        barOneStyle.height = `${newHeight}px`;\r\n                    }, animation_speed_ms);\r\n                    //once we swapped both elements, we reset isSwap and count\r\n                    if (count === 2){\r\n                        isSwap = false;\r\n                        count = 0;\r\n                    }\r\n                }\r\n\r\n            await timer(animation_speed_ms);\r\n            }\r\n            //enable all buttons\r\n            enableB();\r\n        }\r\n        //call load function\r\n        load(callback);\r\n    }\r\n\r\n    /**\r\n     * This functions call getInsertionSortAnimations from sortingAlgorithms.js and uses the return\r\n     * array to create visualizations for insertion sort.\r\n     *  \r\n     * @param {*} callback enable buttons function call \r\n     */\r\n    insertionSort(callback) {\r\n        //get animations array\r\n        const animations = sortingAlgorithms.getInsertionSortAnimations(this.state.array);\r\n        \r\n        //create promise\r\n        const timer = ms => new Promise(res => setTimeout(res, ms))\r\n\r\n        /* load function */\r\n        async function load(enableB){\r\n            //indicate if the next elements in array is a swap or not\r\n            let isSwap = false;\r\n            //count of swaps, count of color changes\r\n            let count = 0, colorCount = 0;\r\n            //loop through animations array;\r\n            for (let i = 0; i < animations.length; i++) {\r\n                const arrayBars = document.getElementsByClassName('array-bar');\r\n                //if animations[i][0] == -1 && animations[i][1] == -1\r\n                //this indicates that the next two elements is swapped\r\n                const [first, second] = animations[i];\r\n                if (first === -1 && second === -1){\r\n                    isSwap = true;\r\n                }\r\n                //color change\r\n                else if (!isSwap && first !== -1 && second !== -1) {\r\n                    colorCount++;\r\n                    const [barOneIdx, barTwoIdx] = animations[i];\r\n                    const barOneStyle = arrayBars[barOneIdx].style;\r\n                    const barTwoStyle = arrayBars[barTwoIdx].style;\r\n                    //if first colorCount, change to sec color, else primary\r\n                    const color = colorCount === 1 ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n                    if (colorCount === 2) colorCount = 0;\r\n                    setTimeout(() => {\r\n                        barOneStyle.backgroundColor = color;\r\n                        barTwoStyle.backgroundColor = color;\r\n                    },  animation_speed_ms);\r\n                } \r\n                //swap\r\n                else if (isSwap && first !== -1 && second !== -1) {\r\n                    count++;\r\n                    const [barOneIdx, newHeight] = animations[i];\r\n                    setTimeout(() => {\r\n                        const barOneStyle = arrayBars[barOneIdx].style;\r\n                        barOneStyle.height = `${newHeight}px`;\r\n                    }, animation_speed_ms);\r\n                    //once we swapped both elements, we reset isSwap and count\r\n                    if (count === 2){\r\n                        isSwap = false;\r\n                        count = 0;\r\n                    }\r\n                }\r\n\r\n            await timer(animation_speed_ms);\r\n            }\r\n            //enable all buttons\r\n            enableB();\r\n        }\r\n        //call load function\r\n        load(callback);\r\n    }\r\n\r\n    /**\r\n     * This functions call getSelectionSortAnimations from sortingAlgorithms.js and uses the return\r\n     * array to create visualizations for selection sort.\r\n     *  \r\n     * @param {*} callback enable buttons function call \r\n     */\r\n    selectionSort(callback) {\r\n        //get animations array\r\n        const animations = sortingAlgorithms.getSelectionSortAnimations(this.state.array);\r\n        \r\n        //create promise\r\n        const timer = ms => new Promise(res => setTimeout(res, ms))\r\n\r\n        /* load function */\r\n        async function load(enableB){\r\n            //indicate if the next elements in array is a swap or not\r\n            let isSwap = false;\r\n            //count of swaps, count of color changes\r\n            let count = 0, colorCount = 0;\r\n            //loop through animations array;\r\n            for (let i = 0; i < animations.length; i++) {\r\n                const arrayBars = document.getElementsByClassName('array-bar');\r\n                const [first, second] = animations[i];\r\n                //if animations[i][0] == -1 && animations[i][1] == -1\r\n                //this indicates that the next two elements is swapped\r\n                if (first === -1 && second === -1){\r\n                    isSwap = true;\r\n                }\r\n                //color change\r\n                else if (!isSwap && first !== -1 && second !== -1) {\r\n                    colorCount++;\r\n                    const [barOneIdx, barTwoIdx] = animations[i];\r\n                    const barOneStyle = arrayBars[barOneIdx].style;\r\n                    const barTwoStyle = arrayBars[barTwoIdx].style;\r\n                    //if first colorCount, change to sec color, else primary\r\n                    const color = colorCount === 1 ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n                    if (colorCount === 2) colorCount = 0;\r\n                    setTimeout(() => {\r\n                        barOneStyle.backgroundColor = color;\r\n                        barTwoStyle.backgroundColor = color;\r\n                    },  animation_speed_ms);\r\n                } \r\n                //swap\r\n                else if (isSwap && first !== -1 && second !== -1) {\r\n                    count++;\r\n                    const [barOneIdx, newHeight] = animations[i];\r\n                    setTimeout(() => {\r\n                        const barOneStyle = arrayBars[barOneIdx].style;\r\n                        barOneStyle.height = `${newHeight}px`;\r\n                    }, animation_speed_ms);\r\n                    //once we swapped both elements, we reset isSwap and count\r\n                    if (count === 2){\r\n                        isSwap = false;\r\n                        count = 0;\r\n                    }\r\n                }\r\n\r\n            await timer(animation_speed_ms);\r\n            }\r\n            //enable all buttons\r\n            enableB();\r\n        }\r\n        //call load function\r\n        load(callback);\r\n    }\r\n\r\n    /* render function to display HTML code */\r\n    render() {\r\n        const {array} = this.state;\r\n\r\n        return (\r\n            <div className=\"array-container\">\r\n                <div className=\"buttons\">\r\n                    <button onClick={() => this.resetArray()}>Generate New Array</button>\r\n                    <div className=\"slide-container\">\r\n                        <p>Change Array Size</p>\r\n                        <input type=\"range\" min=\"4\" max=\"150\" defaultValue=\"75\" \r\n                            step=\"1\" onChange={this.handleChange, e => this.changeArraySize(e.target.value)} className=\"slider\" id=\"barRange\"/>\r\n                    </div>\r\n                    <button onClick={() => {this.mergeSort(this.enableButton); this.disableButton()}}>Merge Sort</button>\r\n                    <button onClick={() => {this.quickSort(this.enableButton); this.disableButton()}}>Quick Sort</button>\r\n                    <button onClick={() => {this.heapSort(this.enableButton); this.disableButton()}}>Heap Sort</button>\r\n                    <button onClick={() => {this.bubbleSort(this.enableButton); this.disableButton()}}>Bubble Sort</button>\r\n                    <button onClick={() => {this.insertionSort(this.enableButton); this.disableButton()}}>Insertion Sort</button>\r\n                    <button onClick={() => {this.selectionSort(this.enableButton); this.disableButton()}}>Selection Sort</button>\r\n                </div>\r\n                <div className=\"bars\">\r\n                    {array.map((value, idx) => (\r\n                    <div\r\n                        className=\"array-bar\"\r\n                        key={idx}\r\n                        style={{\r\n                        backgroundColor: PRIMARY_COLOR,\r\n                        height: `calc(.1 * ${value}vh)`,\r\n                        }}></div>\r\n                    ))}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * \r\n * @param {*} min minimun range\r\n * @param {*} max maximum range\r\n * @returns int between the interval range min and max \r\n */\r\nfunction randomIntFromInterval(min, max) {\r\n  // min and max included\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n","import React from 'react';\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer';\nimport './App.css';\n\n/*\nReact App function\nSortingVisualizer tag containing visualizations\n*/\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}